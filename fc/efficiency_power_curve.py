import numpy as np
from scipy.interpolate import CubicSpline
import matplotlib.pyplot as plt
import pickle

# -------------------------------------------------------------------
# 1) "Digitized" (j, η) pairs for T=473 K (green‐square curve).
#
#    These 18 points were extracted by finding green‐square centroids
#    in the provided plot and mapping pixel‐coordinates back to data‐units.
#    You can tweak or add more points if you want a finer fit.
#   https://doi.org/10.1016/j.seta.2022.102232
# -------------------------------------------------------------------
#
#   (j in A/m²,   η in %)

j_data = 20000 * np.array([0, 0.010121457177244596, 0.03238867068924164, 0.05566801447484513, 0.07692309771323576, 0.10829959951857593, 0.13765184077670323, 0.16700404342453545, 0.19028342582043403, 0.22064779735216775, 0.25607289747252376, 0.28036441014202873, 0.31072878167376244, 0.3562753389713631, 0.39271256936532545, 0.42206481062345275, 0.45242918215518646, 0.4898785428227554, 0.5283401109845208, 0.5647773413784832, 0.6022267020460521, 0.654858325700078, 0.692307686367647, 0.7297570470352158, 0.7601214185669496, 0.7894736598250769, 0.8198380313568105, 0.8572873920243795, 0.8876517635561131, 0.90283394932198, 0.9170040820348304, 0.940283464430729, 0.9554656501965959, 0.9696356284682661, 0.9777328250982981, 0.9848178142341331, 0.9929150108641647])
eta_data = 7/6* 0.01 * np.array([77.5, 70.03027577703709, 63.85380474719604, 60.82612309628746, 58.888406377718425, 56.95069196908716, 55.37629843458981, 54.0441157362647, 53.196363950035185, 52.22750674571955, 51.016434085356124, 50.4108977551744, 49.563145968944895, 48.47318334654315, 47.625431560313636, 46.89878981204581, 46.29325348186409, 45.445501695634576, 44.59774990940506, 43.74999812317555, 42.902246336946035, 41.691173676582615, 40.84342651022866, 39.99567472399915, 39.14792293776963, 38.30017115154012, 37.452419365310604, 36.12024128686106, 34.78806320841151, 34.06141684026811, 33.33477509200028, 31.881486975589052, 30.42819885917783, 28.732699906594362, 27.40051720826925, 25.46280279963799, 22.67733660477722])

j_data_2 = 20000 * np.array([0, 0.05353534789173427, 0.09898989509774776, 0.12929292656842345, 0.17474747377443692, 0.24949496681502242, 0.3090909441202701, 0.35353540569017994, 0.4141414686315313, 0.4595960158375447, 0.5121212395608782, 0.5646464632842118, 0.6171717640721395, 0.6545454720601351, 0.6919192571127248, 0.7292929651007205, 0.7737374266706305, 0.7969697045593919, 0.8343434896119817, 0.8717171975999773, 0.9020202290706529])
P_data = np.array([0, 1000.0002825701673, 1685.1849026150162, 2129.629629629629, 2759.258835404007, 3740.7408820258233, 4481.481622766564, 5018.518235948349, 5685.185326470269, 6166.666525381584, 6703.703844988788, 7203.7032798484515, 7666.666242811414, 7962.962962962962, 8240.74074074074, 8499.999222932038, 8759.259117974176, 8851.851710566769, 8981.481481481482, 9037.036895751953, 8981.481481481482]) / 9037.036895751953


# -------------------------------------------------------------------
# Points from Lorenzo 
# --------------------------------------------------------------------

P_data_realest = 1/0.414391884 * np.array([0.00919735, 0.017800821, 0.026145782, 0.034303366, 0.042307252, 0.050177189, 0.057926157, 0.065563316, 0.07309546, 0.080527811, 0.087864492, 0.09510883, 0.102263553, 0.109330928, 0.11631286, 0.123210964, 0.130026616, 0.136760998, 0.143415126, 0.149989878, 0.156486013, 0.162904186, 0.169244963, 0.175508831, 0.181696207, 0.187807446, 0.193842848, 0.19980266, 0.205687084, 0.211496281, 0.217230372, 0.222889443, 0.228473547, 0.233982703, 0.239416905, 0.244776116, 0.250060274, 0.255269292, 0.260403059, 0.26546144, 0.270444278, 0.275351397, 0.280182595, 0.284937653, 0.289616332, 0.294218369, 0.298743487, 0.303191384, 0.307561742, 0.311854223, 0.316068469, 0.320204101, 0.324260724, 0.328237919, 0.332135251, 0.335952262, 0.339688474, 0.343343388, 0.346916484, 0.35040722, 0.353815031, 0.357139331, 0.360379508, 0.363534928, 0.366604931, 0.369588832, 0.372485918, 0.375295452, 0.378016666, 0.380648763, 0.383190917, 0.38564227, 0.388001932, 0.390268977, 0.392442447, 0.394521343, 0.396504633, 0.39839124, 0.400180048, 0.401869896, 0.403459579, 0.404947843, 0.406333383, 0.407614842, 0.408790809, 0.409859814, 0.410820324, 0.411670744, 0.412409411, 0.41303459, 0.413544469, 0.413937158, 0.414210683, 0.414362978, 0.414391884])
eta_data_realest = np.array([0.733966401, 0.710269997, 0.695494687, 0.684368782, 0.675240145, 0.667372831, 0.660374232, 0.654009967, 0.648128826, 0.642627543, 0.637432438, 0.632489085, 0.627756136, 0.623201429, 0.618799449, 0.614529612, 0.610375062, 0.606321821, 0.602358163, 0.598474153, 0.594661295, 0.590912266, 0.587220702, 0.58358104, 0.579988384, 0.576438398, 0.572927225, 0.569451415, 0.566007865, 0.562593775, 0.559206608, 0.555844053, 0.552503999, 0.54918451, 0.545883805, 0.542600239, 0.539332288, 0.536078537, 0.532837665, 0.529608439, 0.526389701, 0.523180364, 0.519979402, 0.516785845, 0.513598773, 0.510417311, 0.507240627, 0.504067923, 0.500898436, 0.497731433, 0.494566208, 0.491402079, 0.488238385, 0.485074488, 0.481909763, 0.478743604, 0.475575417, 0.472404621, 0.469230644, 0.466052925, 0.462870909, 0.459684049, 0.456491801, 0.453293626, 0.450088989, 0.446877353, 0.443658186, 0.440430951, 0.437195113, 0.433950133, 0.430695466, 0.427430567, 0.424154883, 0.420867852, 0.417568908, 0.414257475, 0.410932967, 0.407594786, 0.404242325, 0.400874961, 0.397492057, 0.394092963, 0.390677009, 0.387243508, 0.383791755, 0.38032102, 0.376830556, 0.373319586, 0.36978731, 0.366232901, 0.362655499, 0.359054215, 0.355428124, 0.351776266, 0.34809764])
da_realest_spline = CubicSpline(P_data_realest, eta_data_realest, bc_type='natural', extrapolate=True)


# Just to confirm we have 18 points:
# assert j_data.shape == eta_data.shape == (18,)
# -------------------------------------------------------------------
# 2) Build a cubic spline over [0, 20 000].
#
#    By default we will do a "natural" spline (second 
#    derivative = 0 at the two ends). If you want a different boundary
#    condition (e.g. "clamped"), you can pass bc_type="clamped" etc.
# -------------------------------------------------------------------
#
spline = CubicSpline(j_data, eta_data, bc_type='natural', extrapolate=True)
def eta_of_j(j):
    """
    Return the interpolated energy‐efficiency [%%] at current density j [A/m²]
    using a cubic‐spline based on the digitized T=473 K curve. 
    Returns NaN if j < 0 or j > 20 000 (no extrapolation).
    """
    j = np.atleast_1d(j)
    out = np.full_like(j, np.nan, dtype=float)
    mask = (j >= j_data.min()) & (j <= j_data.max())
    if np.any(mask):
        out[mask] = spline(j[mask])
    return out if out.shape != () else out.item()

spline2 = CubicSpline(j_data_2, P_data, bc_type='natural', extrapolate=True)
def P_of_j(j):
    """
    Return the interpolated power [W] at current density j [A/m²]
    using a cubic‐spline based on the digitized T=473 K curve. 
    Returns NaN if j < 0 or j > 20 000 (no extrapolation).
    """
    j = np.atleast_1d(j)
    out = np.full_like(j, np.nan, dtype=float)
    mask = (j >= j_data_2.min()) & (j <= j_data_2.max())
    if np.any(mask):
        out[mask] = spline2(j[mask])
    return out if out.shape != () else out.item()


# -------------------------------------------------------------------
# Combine splines to function eta_of_P
# --------------------------------------------------------------------
P_cropped = P_data[0:-1]
j_cropped = j_data_2[0:-1]
eta_cropped = eta_of_j(j_cropped)
print(eta_cropped)



spline_eta_of_P = CubicSpline(P_cropped, eta_cropped, bc_type='natural', extrapolate=True)
filepath = 'fc/spline_eta_of_P.pkl'
with open(filepath, 'wb') as f:
    pickle.dump(da_realest_spline, f, protocol=pickle.HIGHEST_PROTOCOL)


def eta_of_P(P):
    """
    Return the interpolated energy‐efficiency [%%] at power P [W]
    using a cubic‐spline based on the digitized T=473 K curve.
    Returns NaN if P < 0 or P > 9037.036895751953 (no extrapolation).
    """
    P = np.atleast_1d(P)
    out = np.full_like(P, np.nan, dtype=float)
    mask = (P >= P_data_realest.min()) & (P <= P_data_realest.max())
    if np.any(mask):
        out[mask] = da_realest_spline(P[mask])
    return out if out.shape != () else out.item()
    



# -------------------------------------------------------------------
# 3) (Optional) Quick plot to verify.
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Plot original "dots" and the continuous spline
    P_dense = np.linspace(0, 1, 500)
    eta_dense = eta_of_P(P_dense)
    # j_dense = np.linspace(0, 1, 500)
    # eta_dense_j = eta_of_j(j_dense * 20000)
    plt.figure(figsize=(6,4))
    plt.plot(P_data_realest, eta_data_realest, 's', label="Digitized points (473 K)")
    plt.plot(P_dense, eta_dense, '-', label="Cubic‐spline, η(P)")
    # plt.plot(j_dense , eta_dense_j, '-', label="Cubic‐spline, η(j)")
    plt.plot()
    plt.xlabel("Throttle")
    plt.ylabel("Energy Efficiency η [%]")
    plt.title("Cubic‐Spline Interpolator for η at T=473 K")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.show()
    # # Example usage:
    # for test_j in [0, 1000, 5000, 10000, 15000, 20000]:
    #     print(f"η({test_j:.0f} A/m)  {eta_of_j(test_j):.2f} %")




